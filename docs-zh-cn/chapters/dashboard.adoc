## 仪表板(Dashboard)详解

这一部分是关于Dashboard的内容。在这一部分中你不需要写任何代码。这一部分只是解释Dashboard的一些工作原理：

1. 如何配置Vert.x Web以便访问静态资源
2. 如何配置SockJS - Eventbus bridge
3. How to implement a REST endpoint delegating to another REST endpoint (proxy pattern)
4. 如何在浏览器端消费Event Bus代理

Dashboard部分是一个单独的Verticle (`io.vertx.workshop.dashboard.DashboardVerticle`)。

### Vert.x Web与静态文件

正如我们之前所提到的那样，Vert.x Web是一个用于构建Web应用的Vert.x组件。整个架构的核心是 `Router` 对象（路由）。
你可以创建并配置**路由**。对每一个路由，你都需要配置其 _HTTP Method_ 与 _URL路径_ ，并与对应的 `Handler` 相结合。
`router` 对象可以通过下面的代码进行创建：

[source, java]
----
Router router = Router.router(vertx);
----

Vert.x Web提供了一系列的 `Handler` 用于处理各种请求，比如访问静态资源：

[source, java]
----
// 静态内容
router.route("/*").handler(StaticHandler.create());
----


当路由配置完毕后，你需要创建一个HTTP服务端并使用路由来处理HTTP请求：

[source, java]
----
vertx.createHttpServer()
    .requestHandler(router::accept)
    .listen(8080);
----

### SockJS - Event bus bridge

SockJS is a browser JavaScript library that provides a WebSocket-like object. SockJS gives you a coherent, cross-browser,
Javascript API which creates a low latency, full duplex, cross-domain communication channel between the browser and the
web server. Under the hood SockJS tries to use native WebSockets first. If that fails it can use a variety of
browser-specific transport protocols and presents them through WebSocket-like abstractions. SockJS-client does require
a server counterpart to handle the communication. And you know what, Vert.x implements it !

With the SockJS - Event bus bridge, events from the event bus can be sent to browsers and JavaScript code running in
the browser can send messages to the event bus.

To enable the bridge you need thw following code:

[source, java]
----
SockJSHandler sockJSHandler = SockJSHandler.create(vertx);                      // <1>
BridgeOptions options = new BridgeOptions();
options
    .addOutboundPermitted(new PermittedOptions().setAddress("market"))         // <2>
    .addOutboundPermitted(new PermittedOptions().setAddress("portfolio"))
    .addOutboundPermitted(new PermittedOptions().setAddress("service.portfolio"))
    .addInboundPermitted(new PermittedOptions().setAddress("service.portfolio"));

sockJSHandler.bridge(options);                                                 // <3>
router.route("/eventbus/*").handler(sockJSHandler);                            // <4>
----

In (1), we create the `SockJSHandler`. It needs to be configured, as by default, for security reasons, no messages are
 transmitted. A set of permitted addresses configures bridge (2). Outbound addresses are for messages from the event
 bus to the browser, while inbound addresses are for messages from the browser to the event bus. Finally in (3) and
 (4), it configures the handler and create a router in the `router`. The `/eventbus/*` path is used by the SockJS
 client (in the browser) to negotiate the connection, receive and send the messages.

This is not the only bridge that exists for the event bus. There is also a TCP event bus bridge for native systems.
Notice also, that the SockJS bridge can also be used from Node.JS.

### Delegating REST calls

It's often required to implement a REST API on top of another one. This pattern can be very costly on traditional
architecture as each call would block a thread until the call to this second REST API has completed. With Vert.x
delegation is easy, asynchronous and non blocking.

For example in the dashboard, we want to retrieve the list of operations. This list is offered by the audit service.
So in the dashboard we have this route definition:

[source, java]
----
router.get("/operations").handler(this::lastOperations);
----

And the handler is:

[source, java]
----
private void lastOperations(RoutingContext context) {
    HttpEndpoint.get(vertx, discovery, new JsonObject().put("name", "AUDIT"), client -> {
        if (client.failed() || client.result() == null) {
            context.response()
                .putHeader("content-type", "application/json")
                .setStatusCode(200)
                .end(new JsonObject().put("message", "No audit service").encode());
        } else {
            client.result().get("/", response -> {
              response
                  .exceptionHandler(context::fail)
                  .bodyHandler(buffer -> {
                    context.response()
                        .putHeader("content-type", "application/json")
                        .setStatusCode(200)
                        .end(buffer);
                    client.result().close();
                  });
            })
                .exceptionHandler(context::fail)
                .end();
        }
    });
}
----

It retrieves the audit service from the discovery infrastructure and once it gets the HTTP client. It uses it to call
 the audit REST API. The response is simply sent back to the HTTP response. Finally, don't forget to close the HTTP
 client.

### Consuming event bus service from the browser

As said above, there is a bridge between sockJS and the event bus to let the browser sends and receives messages. As
event bus services communicate using event bus messages, it is possible to implement a service client in the browser.
 Vert.x generates this client for you.

So, if you open the `index.html` file, you can see:

[source, html]
----
<script src="libs/portfolio_service-proxy.js"></script>
----

This imports a script generated by Vert.x (in the portfolio project). Then we can use the service as follows:

[source, javascript]
----
var service = new PortfolioService(eventbus, "service.portfolio");
service.getPortfolio(function (err, res) {
   // ....
}
----

Yes, you can call the service method directly from your browser.



