## 第一个Vert.x微服务 - 报价生成器

免责声明：这个报价生成器是虚构的，非真实的，请勿用于现实。况且这就是一堆随机数。。。

### 项目结构

我们来看一看这个项目的结构，其它的项目与此结构相同。

[source]
----
.
├── README.md <--- 组件描述
├── pom.xml <--- Maven配置文件
└── src
    ├── docker
    │   └── config.json <--- 配置文件，启动Docker容器时需要
    └── main
        └── java
            └── io.vertx.workshop.quote
                            ├── GeneratorConfigVerticle.java <--- 各种Verticle
                            ├── QuoteVerticle.java
                            └── RestQuoteAPIVerticle.java
----

我们从 `pom.xml` 文件开始，这个文件决定了Maven的构建方式：

1. 定义各种依赖
2. 构建 _fat-jar_ 文件
3. 构建对应的Docker容器

构建 _Fat-jar_ 是一个给Vert.x应用打包的一个简便方法。一个 _fat-jar_ 里包括了你的应用以及所有的依赖（包括Vert.x本身）。
想要运行应用也很简单，你只需要在终端中使用 `java -jar ....` 命令而不需要指定 `CLASSPATH` 。等一下，我之前提到过Vert.x没有自己的一个打包方式。
是的， _fat-jar_ 非常简便，但这也是唯一的方法咯。

生成的 _fat-jar_ 对应的Main Class是 `io.vertx.core.Launcher`，但你也可以用你自己的类来替代它。 `Launcher` 类创建Vert.x实例，
对Vert.x进行配置并且对 _main-verticle_ 进行部署。

我们也要对 `pom.xml` 文件进行配置以便创建Docker容器以及启动应用。 

### Verticle

你可能已经注意到了，核心代码被分为3个 `Verticle` ，但Verticle又是啥呢？Verticle是构成Vert.x应用的一种方法。我们不强制你使用Verticle，
但它的确非常方便。Verticle是一串基于Vert.x实例部署的代码。Verticle可以访问 `vertx` 实例，并且还可以对其它Verticles进行部署。

我们打开 `GeneratorConfigVerticle` 类的代码，看看 `start` 方法：

[source, java]
----
@Override
public void start() {
    super.start();

    JsonArray quotes = config().getJsonArray("companies");
    for (Object q : quotes) {
      JsonObject company = (JsonObject) q;
      // 对Verticle进行部署的时候可以提供配置选项
      vertx.deployVerticle(MarketDataVerticle.class.getName(),
         new DeploymentOptions().setConfig(company));
    }

    vertx.deployVerticle(RestQuoteAPIVerticle.class.getName());

    publishMessageSource("market-data", ADDRESS, rec -> {
      if (!rec.succeeded()) {
        rec.cause().printStackTrace();
      }
      System.out.println("Market-Data service published : " + rec.succeeded());
    });
}
----

Verticle可以通过 `config()` 方法来获取配置信息。我们的服务就是从此处获取要模拟的公司的信息。配置信息是一个 `JsonObject` 实例。
在Vert.x中，JSON的使用非常普遍，所以你将会在这个实验中见到大量的JSON数据。

`start` 方法的另一部分与我们之前提到的服务发现有关。我们的报价生成器组件报价并发送到Event Bus上，但为了让其他的组件知道消息的来源（即地址），
生成器会进行服务注册。 服务的名字是 `market-data` ，消息发送的地址是 `ADDRESS` 。最后一个参数是一个 `Handler` ，当注册完成时会调用这个函数
来进行通知。 `handler` 会接受一种 `AsyncResult` 类型的数据。

记住，Vert.x推崇异步、非阻塞的开发模型。发布服务很可能会占用不少时间（实际上确实是这样，因为它需要创建一条记录，将其写到后端然后通知所有组件），
所以我们不能阻塞Event Loop线程，此方法是异步的。异步方法的最后一个参数都是 `Handler` ，它会在异步操作完成后被调用。
`Handler` 会被同一个Event Loop线程（即调用异步方法的线程）调用。因为异步操作可能会失败， `Handler` 会接受 `AsyncResult` 类型的类型参数
来表示异步操作是否成功进行。你将会在许多Vert.x应用中见到下面的模式：

[source, java]
----
 // 异步方法，返回类型为X的结果
 operation(param1, param2, Handler<AsyncResult<X>>);

 // Handler接受X类型的对象

 ar -> {
   if (ar.succeeded()) {
      X x = ar.result();
      // Do something with X
   } else {
      // it failed
      Throwable cause = ar.cause();
   }
 }
----



If you remember the architecture, the quote generator also provides a HTTP endpoint returning the last values of the
quotes (but, you are going to work on it). This _service_ is not published, as we are going to "publish" it using
Docker (no code required, Docker publishes it).

### The consolidation endpoint

It's time for you to develop some parts of the application (I know you have pins and needles in your fingers). Open the
`RestQuoteAPIVerticle`. It's a verticle class extending `AbstractVerticle`. In the `start` method you need to:

1. Register an event bus consumer to collect the last quotations (in the `quotes` map)
2. Handle HTTP requests to return the list of quotes, or a single quote if the `name` (query) param is set.

Let's do that....

#### Implementing a Handler to receive events

The first action is about creating a `Handler`, so a method that is invoked on event. Here, the `Handler` is going to
be called for every messages sent on the event bus on a specific `address` (receiving each quote sent by the generator).
 In the `Handler` body, write:

[source, java,role=assignment]
----
JsonObject quote = message.body(); // 1
quotes.put(quote.getString("name"), quote); // 2
----

First, it retrieves the message body (1). It's a JSON object, and stores it in the `quotes` map (2).

#### Implementing a Handler to handle HTTP requests

Let's now implement the second point.  To handle the HTTP requests, we need a HTTP server. Fortunately, Vert.x lets
you create HTTP servers using:

[source, java]
----
vertx.createHttpServer()
    .requestHandler(request -> {...})
    .listen(port, resultHandler);
----


Replace the content of the `requestHandler` (a handler called on every incoming HTTP request) by:

[source, java, role=assignment]
----
HttpServerResponse response = request.response()    // <1>
    .putHeader("content-type", "application/json");
String company = request.getParam("name");          // <2>
if (company == null) {
    String content = Json.encodePrettily(quotes);   // <3>
    response
        .end(content);                              // <4>
 } else {
    JsonObject quote = quotes.get(company);
    if (quote == null) {
      response.setStatusCode(404).end();            // <5>
    } else {
      response.end(quote.encodePrettily());
    }
 }
----
<1> Get the `response` object from the `request`
<2> Gets the `name` parameter (query parameter)
<3> Encode the map to JSON
<4> Write the response and flush it using `end(...)`
<5> If the given name does not match a company, set the status code to `404`

You may wonder why synchronization is not required. Indeed we write in the map and read from it without any
synchronization constructs. Here is one of the main feature of Vert.x: all this code is going to be executed by
the **same** event loop, so it's always accessed by the **same** thread, never concurrently.

TIP: The `Map<String, JsonObject>` could be replaced by a simple `JsonObject` as they behave as a `Map<String, Object>`.

### Time to start the quote generator

First, let's build the docker image. In the terminal, execute:

----
cd quote-generator
mvn package docker:build
----

Then, open a new terminal and launch:

----
docker run -p 8081:8080 --rm --name quote-generator vertx-microservice-workshop/quote-generator
----

Let's analyze this docker command. It runs a container created from the image we just built
(`vertx-microservice-workshop/quote-generator`). We give it a name (`quote-generator`). The `-p` option configure the
port forwarding. The port `8080` of the application is now exposed on the port `8081` of your machine (or the
docker-machine). In our microservice world, it also means that the HTTP endpoint becomes discoverable.

Let's now open a browser and have a look to http://dockerhost:8081.

It should return something like:

----
{
  "MacroHard" : {
    "volume" : 100000,
    "shares" : 51351,
    "symbol" : "MCH",
    "name" : "MacroHard",
    "ask" : 655.0,
    "bid" : 666.0,
    "open" : 600.0
  },
  "Black Coat" : {
    "volume" : 90000,
    "shares" : 45889,
    "symbol" : "BCT",
    "name" : "Black Coat",
    "ask" : 654.0,
    "bid" : 641.0,
    "open" : 300.0
  },
  "Divinator" : {
    "volume" : 500000,
    "shares" : 251415,
    "symbol" : "DVN",
    "name" : "Divinator",
    "ask" : 877.0,
    "bid" : 868.0,
    "open" : 800.0
  }
}
----

It gives the current details of each quotes. The data is updated every 3 seconds, so refresh your browser to get
the latest data.

Let's now launch the dashboard. In another terminal, navigate to `$project-home/trader-dashboard` and execute:

[source]
----
mvn clean package docker:build
docker run -p 8083:8080 --rm --name dashboard vertx-microservice-workshop/trader-dashboard
----

TIP: If Docker is yelling with something like `Error response from daemon: Conflict. The name "/xyz" is
already in use by container...`, no problem, let be more convincing and launch `docker rm -f xyz` and
then relaunch the command.

Then, open your browser to http://dockerhost:8083. You should see:

image::dashboard-initial-state.png[Dashboard, 800]

Some parts have no _content_, and it's normal as it's just the beginning...

### You are not a financial expert ?

So maybe you are not used to the financial world and words... I'm not too, and this is a overly simplified version.
Let's define the important fields:

* `name` : the company name
* `symbol` : short name
* `shares` : the number of stock that can be bought
* `open` : the stock price when the session opened
* `ask` : the price of the stock when you buy them (seller price)
* `bid` : the price of the stock when you sell them (buyer price)

You can check https://en.wikipedia.org/wiki/Financial_quote[Wikipedia] for more details.
